<!DOCTYPE html>
<!--
 * @name            jPulse Framework / Site / WebApp / View / Hello App Cluster / Code Examples
 * @tagline         Implementation Examples for App Clustering
 * @description     Complete code examples for both client-side and server-side broadcasting patterns
 * @file            site/webapp/view/hello-app-cluster/code-examples.shtml
 * @version         0.9.7
 * @release         2025-10-12
 * @repository      https://github.com/peterthoeny/jpulse-framework
 * @author          Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @copyright       2025 Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @license         AGPL v3, see LICENSE file
 * @genai           60%, Cursor 1.7, Claude Sonnet 4
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Examples - App Cluster Demo - {{app.shortName}}</title>
    {{file.include "jpulse-header.tmpl"}}
    <style>
        .local-pattern-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .local-pattern-comparison {
                grid-template-columns: 1fr;
            }
        }

        .local-pattern-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }

        .local-pattern-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .local-pattern-icon {
            font-size: 24px;
        }

        .local-pattern-title {
            font-size: 16px;
            font-weight: bold;
            margin: 0;
        }

        .local-step-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .local-step-list li {
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
            position: relative;
            padding-left: 30px;
        }

        .local-step-list li:last-child {
            border-bottom: none;
        }

        .local-step-list li::before {
            content: counter(step);
            counter-increment: step;
            position: absolute;
            left: 0;
            top: 8px;
            background: #007bff;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .local-step-list {
            counter-reset: step;
        }

        .local-api-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
        }

        .local-api-table th,
        .local-api-table td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }

        .local-api-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .local-api-table tr:hover {
            background-color: #f8f9fa;
        }

        .local-method-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .local-method-badge.get {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .local-method-badge.post {
            background-color: #d4edda;
            color: #155724;
        }

        .local-method-badge.put {
            background-color: #fff3cd;
            color: #856404;
        }

        .local-method-badge.delete {
            background-color: #f8d7da;
            color: #721c24;
        }

        .local-highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }

        .local-highlight h4 {
            margin-top: 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="jp-main">
        <div class="jp-container-1200">
            <div class="jp-page-header">
                <h1>üíª Code Examples</h1>
                <span class="jp-subtitle">Complete implementation examples for both broadcasting patterns</span>
            </div>

            <!-- Sub-navigation -->
            <nav class="jp-btn-nav-group">
                <a href="/hello-app-cluster/" class="jp-btn jp-btn-outline">üìñ Overview</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-app-cluster/notifications.shtml" class="jp-btn jp-btn-outline">üì¢ Global Notifications</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-app-cluster/collaborative-todo.shtml" class="jp-btn jp-btn-outline">‚úÖ Collaborative To-Do</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-app-cluster/code-examples.shtml" class="jp-btn jp-btn-outline jp-btn-active">üíª Code Examples</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-app-cluster/architecture.shtml" class="jp-btn jp-btn-outline">üèóÔ∏è Architecture</a>
            </nav>

            <!-- Pattern Comparison -->
            <div class="jp-card">
                <h2>üîÑ Broadcasting Patterns Overview
                    <span class="jp-subheading">Understanding the two different approaches to cluster communication</span>
                </h2>
                <div class="jp-card-content">
                    <div class="local-pattern-comparison">
                        <!-- Client-Side Pattern -->
                        <div class="local-pattern-card">
                            <div class="local-pattern-header">
                                <div class="local-pattern-icon">üì¢</div>
                                <h3 class="local-pattern-title">Client-Side Broadcasting</h3>
                            </div>
                            <p><strong>Direct client-to-Redis communication</strong></p>
                            <ol class="local-step-list">
                                <li>Client calls <code>jPulse.appCluster.broadcast.publish()</code></li>
                                <li>Message sent directly to Redis</li>
                                <li>Redis distributes to all server instances</li>
                                <li>All connected clients receive broadcast</li>
                            </ol>
                            <div class="local-highlight">
                                <h4>üí° Best For:</h4>
                                <p>Simple notifications, chat messages, real-time alerts that don't need persistence or validation.</p>
                            </div>
                        </div>

                        <!-- Server-Side Pattern -->
                        <div class="local-pattern-card">
                            <div class="local-pattern-header">
                                <div class="local-pattern-icon">‚úÖ</div>
                                <h3 class="local-pattern-title">Server-Side Broadcasting</h3>
                            </div>
                            <p><strong>Full MVC with server processing</strong></p>
                            <ol class="local-step-list">
                                <li>Client sends standard HTTP request to API</li>
                                <li>Server validates, processes, saves to database</li>
                                <li>Server publishes change to Redis</li>
                                <li>All server instances receive and sync clients</li>
                            </ol>
                            <div class="local-highlight">
                                <h4>üí° Best For:</h4>
                                <p>Production applications requiring validation, persistence, audit trails, and business logic.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Client-Side Broadcasting Examples -->
            <div class="jp-card">
                <h2>üì¢ Client-Side Broadcasting Examples
                    <span class="jp-subheading">Simple direct broadcasting without server-side logic</span>
                </h2>

                <!-- Basic Publishing -->
                <h3>üì§ Publishing a Message</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">const notificationChannel = 'view:helloNotification:message:sent';
const notificationData = {
    message: 'System maintenance scheduled for 10 PM UTC.',
    type: 'warning',
    sender: '&#123;&#123;user.username&#125;&#125;' || 'guest',
    senderName: ('&#123;&#123;user.firstName&#125;&#125;' || 'Anonymous') + ' '
             +  ('&#123;&#123;user.lastName&#125;&#125;' || 'User'),
    timestamp: new Date().toISOString()
};

// This call automatically handles the WebSocket connection and
// sends the message to the server, which then broadcasts it via Redis.
jPulse.appCluster.broadcast.publish(notificationChannel, notificationData);

jPulse.UI.toast.show('üì° Notification broadcasted!', 'success');</code></pre>
                </div>

                <!-- Subscribing to Messages -->
                <h3>üì• Subscribing to a Message</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">const notificationChannel = 'view:helloNotification:message:sent';

// Listen for notifications from all cluster instances.
// The broadcast object automatically handles the WebSocket connection.
jPulse.appCluster.broadcast.subscribe(notificationChannel, (data) => {
    console.log('üì° Received notification:', data);

    // Add the notification to the UI feed
    addNotificationToFeed(data);

    // Show a toast only if the message came from another tab or user
    if (data.uuid !== jPulse.appCluster.broadcast.getUuid()) {
        jPulse.UI.toast.show(
            `New message from ${data.senderName}`,
            'info'
        );
    }
});

function addNotificationToFeed(notification) {
    // ... logic to update the DOM ...
}</code></pre>
                </div>

                <!-- Channel Naming Convention -->
                <h3>üè∑Ô∏è Channel Naming Convention</h3>
                <div class="jp-source-code" data-lang="text" data-show-lang="true">
                    <pre><code class="language-text">// Pattern: {layer}:{component}:{domain}:{action}

// ‚úÖ Good examples from our demo:
view:helloNotification:message:sent
controller:helloClusterTodo:list:changed
controller:helloClusterTodo:item:updated

// ‚ùå Avoid these patterns:
'notifications'           // Too generic, will cause collisions
'user-update'             // No layer or domain specification
'myApp:something'         // Inconsistent, not descriptive</code></pre>
                </div>
            </div>

            <!-- Server-Side Broadcasting Examples -->
            <div class="jp-card">
                <h2>‚úÖ Server-Side Broadcasting Examples
                    <span class="jp-subheading">Full MVC pattern with database persistence and validation</span>
                </h2>

                <!-- Controller Implementation -->
                <h3>üéõÔ∏è Controller: `apiCreate` Method</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">import HelloTodoModel from '../model/helloTodo.js';

class HelloClusterTodoController {
    static async apiCreate(req, res) {
        try {
            const { text } = req.body;

            // 1. Validate input on the server
            if (!text || typeof text !== 'string' || text.trim().length === 0) {
                return res.status(400).json({
                    success: false, message: 'Task description is required'
                });
            }

            // 2. Prepare user data
            const userName = req.session?.user?.username || 'guest';
            const userFirstName = req.session?.user?.firstName || 'Anonymous';
            const userLastName = req.session?.user?.lastName || 'User';

            // 3. Create document using the Model (handles database interaction)
            const createdTodo = await HelloTodoModel.create({
                title: text.trim(),
                username: userName,
                userFirstName,
                userLastName
            });

            // 4. Broadcast the change to all other server instances
            await HelloClusterTodoController._broadcastChange('created', createdTodo, req);

            // 5. Return success response to the original client
            res.status(201).json({ success: true, todo: createdTodo });

        } catch (error) {
            global.LogController.logError(req, 'helloClusterTodo.apiCreate', `error: ${error.message}`);
            res.status(500).json({ success: false, message: 'Failed to create todo' });
        }
    }
    // ... other methods: apiGet, apiToggle, apiDelete ...
}</code></pre>
                </div>

                <!-- Broadcasting Method -->
                <h3>üì° Controller: `_broadcastChange` Method</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">static async _broadcastChange(action, todo, req) {
    // Abort if Redis is not available (graceful fallback)
    if (!global.RedisManager || !global.RedisManager.isRedisAvailable()) {
        global.LogController?.logWarn(req, '..._broadcastChange', 'Redis not available, skipping broadcast');
        return;
    }

    // 1. Prepare a rich payload for other clients
    const senderName = (req.session?.user?.firstName
        ? `${req.session.user.firstName} ${req.session.user.lastName}`
        : req.session?.user?.username) || 'Anonymous User';
    const sender = req.session?.user?.username || 'guest';

    const broadcastPayload = {
        todo: todo,
        action: action,
        sender: sender,
        senderName: senderName,
        uuid: req.body.uuid || null // Pass client UUID to prevent echo
    };

    // 2. Determine the correct channel based on the action
    const channel = (action === 'created' || action === 'deleted')
        ? 'controller:helloClusterTodo:list:changed'
        : 'controller:helloClusterTodo:item:updated';

    // 3. Publish directly to Redis using the RedisManager
    try {
        await global.RedisManager.publishBroadcast(channel, broadcastPayload);
        global.LogController?.logInfo(req, '..._broadcastChange', `Broadcasted [${action}]`);
    } catch (error) {
        global.LogController?.logError(req, '..._broadcastChange', `Failed to broadcast: ${error.message}`);
    }
}</code></pre>
                </div>

                <!-- Client-Side API Calls -->
                <h3>üåê Client-Side: `handleAddTask` Method</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">async handleAddTask(e) {
    e.preventDefault();
    const text = this.elements.taskDescription.value.trim();
    if (!text) return;

    // ... (disable button, show spinner) ...

    try {
        // 1. Send a standard POST request to the API
        const response = await fetch('/api/1/helloClusterTodo', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: text })
        });

        const result = await response.json();
        if (result.success) {
            // 2. SUCCESS! Clear the form.
            this.elements.taskDescription.value = '';
            // 3. DO NOT update the UI here. Wait for the broadcast message
            //    from the server. This is the key to consistency.
        } else {
            throw new Error(result.message || 'Failed to add task');
        }
    } catch (error) {
        this.showToast(`Error: ${error.message}`, 'error');
    } finally {
        // ... (re-enable button) ...
    }
}</code></pre>
                </div>
            </div>

            <!-- API Reference -->
            <div class="jp-card">
                <h2>üìö API Reference
                    <span class="jp-subheading">Complete API endpoints for the collaborative todo demo</span>
                </h2>
                <table class="local-api-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Endpoint</th>
                            <th>Description</th>
                            <th>Body/Params</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="local-method-badge get">GET</span></td>
                            <td><code>/api/1/helloClusterTodo</code></td>
                            <td>Get all todos</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td><span class="local-method-badge post">POST</span></td>
                            <td><code>/api/1/helloClusterTodo</code></td>
                            <td>Create a new todo</td>
                            <td><code>{ text }</code></td>
                        </tr>
                        <tr>
                            <td><span class="local-method-badge put">PUT</span></td>
                            <td><code>/api/1/helloClusterTodo/:id/toggle</code></td>
                            <td>Toggle todo completion</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td><span class="local-method-badge delete">DELETE</span></td>
                            <td><code>/api/1/helloClusterTodo/:id</code></td>
                            <td>Delete todo</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td><span class="local-method-badge get">GET</span></td>
                            <td><code>/api/1/helloClusterTodo/stats</code></td>
                            <td>Get todo statistics</td>
                            <td>-</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Broadcasting API Reference -->
            <div class="jp-card">
                <h2>üì° Broadcasting API Reference
                    <h2>üì° Broadcasting API Reference</h2>
                    <span class="jp-subheading">Core jPulse broadcasting methods and patterns</span>
                </h2>

                <!-- Quick Reference -->
                <h3>‚ö° Quick Reference</h3>
                <table class="local-api-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>publish(channel, data)</code></td>
                            <td>Send message to all cluster instances</td>
                            <td><code>jPulse.appCluster.broadcast.publish('my:channel', data)</code></td>
                        </tr>
                        <tr>
                            <td><code>subscribe(channel, callback)</code></td>
                            <td>Listen for messages on channel</td>
                            <td><code>jPulse.appCluster.broadcast.subscribe('my:channel', fn)</code></td>
                        </tr>
                        <tr>
                            <td><code>unsubscribe(channel)</code></td>
                            <td>Stop listening to channel</td>
                            <td><code>jPulse.appCluster.broadcast.unsubscribe('my:channel')</code></td>
                        </tr>
                    </tbody>
                </table>

                <!-- Server-Side Broadcasting -->
                <h3>üñ•Ô∏è Server-Side Broadcasting</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">// In your controller method, after a database operation:
const payload = {
    action: 'created',
    data: newRecord,
    sender: req.session.user.username,
    // ... any other relevant data
};

// Publish directly using RedisManager for server-to-server communication
await global.RedisManager.publishBroadcast(
    'controller:myApp:data:updated',
    payload
);</code></pre>
                </div>

                <!-- Error Handling -->
                <h3>‚ö†Ô∏è Error Handling &amp; Fallbacks</h3>
                <div class="jp-source-code" data-lang="javascript" data-show-lang="true">
                    <pre><code class="language-javascript">// Client-side: jPulse.appCluster.broadcast handles this automatically.
// If Redis is unavailable, it falls back to local-only mode (messages
// are only delivered within the same browser tab). No extra code needed.

// Server-side: The _broadcastChange method includes a check.
if (!global.RedisManager || !global.RedisManager.isRedisAvailable()) {
    // The operation still succeeds locally, but no broadcast is sent.
    // This allows the app to function in a single-instance mode.
    return;
}</code></pre>
                </div>
            </div>

            <!-- Navigation -->
            <div class="jp-btn-nav-group">
                <a href="/" class="jp-btn jp-btn-outline">üè† Home</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello/" class="jp-btn jp-btn-outline">üåê Hello World Site Demos</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-todo/" class="jp-btn jp-btn-outline">üìã To-Do MVC Demo</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-vue/" class="jp-btn jp-btn-outline">üîÑ Vue.js SPA Demo</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-websocket/" class="jp-btn jp-btn-outline">ÔøΩ WebSocket Real-Time Demo</a>
                <span class="jp-btn-nav-arrow">‚Üí</span>
                <a href="/hello-app-cluster/" class="jp-btn jp-btn-active">üåç App Cluster Demo</a>
            </div>
        </div>
    </div>

    {{file.include "jpulse-footer.tmpl"}}
</body>
</html>
