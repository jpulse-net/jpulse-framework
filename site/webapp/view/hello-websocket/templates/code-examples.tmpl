// Code examples component, site/webapp/view/hello-websocket/templates/code-examples.tmpl
/**
 * @name            jPulse Framework / Site / WebApp / View / Hello WebSocket / Templates / Code Examples
 * @tagline         Code examples component of the WebSocket demo
 * @description     This component shows code examples of the WebSocket demo
 * @file            site/webapp/view/hello-websocket/templates/code-examples.tmpl
 * @version         1.6.20
 * @release         2026-02-20
 * @repository      https://github.com/jpulse-net/jpulse-framework
 * @author          Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @copyright       2025 Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @license         BSL 1.1 -- see LICENSE file; for commercial use: team@jpulse.net
 * @genai           60%, Cursor 2.4, Claude Sonnet 4.5
 */

window.helloWebSocketViews = window.helloWebSocketViews || {};

window.helloWebSocketViews.CodeExamples = {
    template: `
<div class="jp-card">
    <h2 class="jp-card-dialog-heading">üíª Code Examples</h2>

    <p>Copy-paste ready code for implementing WebSocket patterns in your own applications. Covers Pattern A (REST + WebSocket sync), Pattern B (WebSocket for CRUD with Redis), and client patterns (debounce, focus, view-supplied username).</p>

    <!-- Server-Side Code -->
    <div class="local-code-example">
        <h3>üñ•Ô∏è Server-Side: Register WebSocket Namespace</h3>
        <p>Create a controller to handle WebSocket connections and messages:</p>

        <h4>üìÑ site/webapp/controller/myWebsocket.js</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>import WebSocketController from '../../../webapp/controller/websocket.js';

class MyWebsocketController {

    static wsHandle = null;

    static async initialize() {
        const ns = WebSocketController.createNamespace('/api/1/ws/my-app', {
            requireAuth: false,
            requireRoles: []
        });
        this.wsHandle = ns;

        ns.onConnect(({ clientId, ctx }) => {
            const username = ctx?.username || 'guest';
            console.log(\`\${username} connected\`);
            ns.sendToClient(clientId, {
                type: 'welcome',
                data: { message: 'Connected to my app!' }
            }, ctx);
        })
        .onMessage(({ clientId, message, ctx }) => {
            const username = ctx?.username || 'guest';
            if (message.type === 'chat-message') {
                ns.broadcast({
                    type: 'chat-message',
                    data: { username, message: message.message, timestamp: Date.now() }
                }, ctx);
            }
        })
        .onDisconnect(({ clientId, ctx }) => {
            const username = ctx?.username || 'guest';
            console.log(\`\${username} disconnected\`);
        });
    }
}

export default MyWebsocketController;</pre></div>
    </div>

    <!-- Client-Side Code -->
    <div class="local-code-example">
        <h3>üåê Client-Side: Connect and Communicate</h3>
        <p>In your Vue.js component or vanilla JavaScript:</p>

        <h4>Basic Connection with Configuration</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// In your Vue component or application initialization:
mounted() {
    // Configure WebSocket UUID storage BEFORE making connections
    jPulse.ws.configure({ uuidStorage: 'session' }); // per-tab (default)
    // jPulse.ws.configure({ uuidStorage: 'local' });   // persistent across sessions
    // jPulse.ws.configure({ uuidStorage: 'memory' });  // per-page load only

    // Now connect to WebSocket namespace
    const ws = jPulse.ws.connect('/api/1/ws/my-app')
        .onMessage((msg) => {
            if (msg.success) {
                // msg.data = app payload { type, data?, username? }
                console.log('Received:', msg.data?.type, msg.data);
            } else {
                console.error('Error:', msg.error);
            }
        })
        .onStatusChange((status, oldStatus) => {
            // Status values: 'connecting', 'connected', 'reconnecting', 'disconnected'
            console.log(\`Connection: \${oldStatus} ‚Üí \${status}\`);
        });

    // Send message (client sends flat; server can use { type, data } for responses)
    ws.send({ type: 'chat-message', message: 'Hello, world!' });

    // Check connection status
    if (ws.isConnected()) {
        console.log('Ready to send messages');
    }

    // Disconnect when done (typically in beforeUnmount)
    // ws.disconnect();
}</pre></div>
    </div>

    <!-- Vue.js Integration -->
    <div class="local-code-example">
        <h3>‚ö° Vue.js Integration</h3>
        <p>Using WebSocket in a Vue component with reactive data:</p>

        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>const MyApp = {
    data() {
        return {
            ws: null,
            status: 'disconnected',
            messages: []
        };
    },

    mounted() {
        // Configure UUID storage before connecting
        jPulse.ws.configure({ uuidStorage: 'session' }); // or 'local' or 'memory'

        this.connect();
    },

    beforeUnmount() {
        if (this.ws) {
            this.ws.disconnect();
        }
    },

    methods: {
        connect() {
            this.ws = jPulse.ws.connect('/api/1/ws/my-app')
                .onMessage((msg) => {
                    if (msg.success) {
                        const payload = msg.data ?? {};
                        if (payload.type === 'chat-message') {
                            this.messages.push({ ...payload.data, type: payload.type });
                        }
                    }
                })
                .onStatusChange((status) => {
                    // Reactive status update
                    this.status = status;
                });
        },

        sendMessage(text) {
            if (this.ws && this.ws.isConnected()) {
                this.ws.send({
                    type: 'chat-message',
                    message: text
                });
            }
        }
    },

    template: \`
        &lt;div&gt;
            &lt;div&gt;Status: &#123;&#123; status &#125;&#125;&lt;/div&gt;
            &lt;div v-for="msg in messages"&gt;
                &#123;&#123; msg.username &#125;&#125;: &#123;&#123; msg.message &#125;&#125;
            &lt;/div&gt;
            &lt;button @click="sendMessage('Hello!')"&gt;Send&lt;/button&gt;
        &lt;/div&gt;
    \`
};</pre></div>
    </div>

    <!-- REST API + WebSocket Pattern -->
    <div class="local-code-example">
        <h3>üîÑ Pattern: REST API + WebSocket Hybrid</h3>
        <p>Best practice for adding real-time to existing applications:</p>

        <h4>Server-Side Controller</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// In your existing REST controller (e.g., todoController.js)
import MyWebsocketController from './myWebsocket.js';

class TodoController {

    static async apiCreate(req, res) {
        try {
            // 1. Validate and create via REST API (existing code)
            const todo = await TodoModel.create(req.body);

            // 2. Broadcast to WebSocket clients (ctx = null when called from REST; no connection)
            const ns = MyWebsocketController.wsHandle;
            if (ns) {
                ns.broadcast({
                    type: 'todo-created',
                    data: { todo, username: req.session?.user?.username || 'guest' }
                }, null);
            }

            // 3. Return REST API response (existing code)
            res.json({ success: true, data: todo });

        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }
}

export default TodoController;</pre></div>

        <h4>Client-Side (Vue.js)</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>const TodoApp = {
    data() {
        return {
            ws: null,
            todos: []
        };
    },

    async mounted() {
        // 1. Load initial data via REST API
        await this.loadTodos();

        // 2. Connect to WebSocket for live updates
        this.ws = jPulse.ws.connect('/api/1/ws/my-app')
            .onMessage((msg) => {
                if (msg.success) {
                    const payload = msg.data ?? {};
                    if (payload.type === 'todo-created') {
                        const d = payload.data ?? {};
                        const exists = this.todos.find(t => t._id === d.todo?._id);
                        if (!exists && d.todo) this.todos.unshift(d.todo);
                    }
                }
            });
    },

    methods: {
        async loadTodos() {
            // Use REST API for initial load
            const response = await jPulse.api.get('/api/1/todos');
            if (response.success) {
                this.todos = response.data;
            }
        },

        async addTodo(title) {
            // Use REST API for mutations
            const response = await jPulse.api.post('/api/1/todos', { title });
            // No need to manually add to array - WebSocket will notify us!
        }
    }
};</pre></div>

        <p class="jp-help-text jp-mt-15">
            üí° <strong>Why this pattern?</strong> REST API does validation, persistence, and error handling.
            WebSocket provides instant notifications. Best of both worlds!
        </p>
    </div>

    <!-- Pattern B: WebSocket for CRUD -->
    <div class="local-code-example">
        <h3>üìù Pattern B: WebSocket for CRUD (Sticky Notes)</h3>
        <p>For live collaborative UIs (canvas, boards): mutations go over WebSocket; server persists and broadcasts. No REST for these operations.</p>

        <h4>Server-Side: Notes Namespace + Redis Store</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// In site/webapp/controller/helloWebsocket.js (notes namespace)
notes.onMessage(async ({ clientId, message: data, ctx }) => {
    const username = (data.username != null && String(data.username).trim() !== '')
        ? String(data.username).trim().slice(0, 100)
        : (ctx?.username || 'guest');

    if (data.type === 'note-create') {
        const note = { id: crypto.randomUUID(), x: data.x ?? 20, y: data.y ?? 20,
            text: (data.text ?? '').slice(0, 500), color: (data.color ?? '#fff9c4').slice(0, 20),
            createdAt: Date.now(), createdBy: username };
        await this._notesCreate(note);
        notes.broadcast({ type: 'note-created', data: { note, username } }, ctx);
    } else if (data.type === 'note-update') {
        const note = await this._notesUpdate(data.id, { x: data.x, y: data.y, text: data.text });
        if (note) notes.broadcast({ type: 'note-updated', data: { note, username } }, ctx);
    } else if (data.type === 'note-delete') {
        const removed = await this._notesDelete(data.id);
        if (removed) notes.broadcast({ type: 'note-deleted', data: { noteId: data.id, username } }, ctx);
    }
});</pre></div>
        <p class="jp-help-text jp-mt-10">
            <code>_notesCreate</code> / <code>_notesUpdate</code> / <code>_notesDelete</code> use <code>RedisManager.cacheGetObject</code> and <code>cacheSetObject</code> so notes persist and sync across server instances.
        </p>

        <h4>Client-Side: Create at Click, Debounce Text, Focus</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// Create note at click position (offset so typing area is near click)
onCanvasClick(event) {
    const rect = event.currentTarget.getBoundingClientRect();
    const offsetX = 20, offsetY = 54;
    const x = Math.min(90, Math.max(0, ((event.clientX - rect.left - offsetX) / rect.width) * 100));
    const y = Math.min(90, Math.max(0, ((event.clientY - rect.top - offsetY) / rect.height) * 100));
    this.pendingFocusAfterCreate = true;
    this.notesWs.send({ type: 'note-create', username: this.notesUsername(), x, y, text: '', color: '#fff9c4' });
}

// In handleNotesMessage(msg), payload = msg.data ?? {}; then in note-created branch:
if (this.pendingFocusAfterCreate) {
    this.pendingFocusAfterCreate = false;
    const noteId = payload.note?.id;
    setTimeout(() => {
        const textarea = this.$el?.querySelector('.local-note[data-note-id="' + noteId + '"] .local-note-text');
        if (textarea?.focus) textarea.focus();
    }, 100);
}</pre></div>

        <h4>Client-Side: Handling note-updated (avoid echo overwrite)</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// In handleNotesMessage(message): payload = message.data ?? {}
} else if (payload.type === 'note-updated') {
    const index = this.notes.findIndex((n) => n.id === payload.note?.id);
    if (index !== -1 && payload.note) {
        if (this.textDebounce && this.textDebounce[payload.note.id]) return;
        this.notes[index] = payload.note;
    }
}</pre></div>
        <p class="jp-help-text jp-mt-10">
            ‚ö†Ô∏è <strong>Gotcha:</strong> Server broadcasts to all clients including sender. Without the <code>textDebounce</code> check, your own (stale) echo overwrites the textarea while the user types and drops characters ‚Äî worse under load or in a cluster.
        </p>

        <h4>View-Supplied Username (Handlebars)</h4>
        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// In template (expanded server-side): username from session or "guest"
notesUsername() {
    return '&#123;&#123; "&#123;&#123;string.default user.username \"guest\"&#125;&#125;" }&#125;&#125;';
}
// Send with every note message so server uses it when present
this.notesWs.send({ type: 'note-create', username: this.notesUsername(), x, y, ... });</pre></div>

        <p class="jp-help-text jp-mt-15">
            üí° <strong>When to use Pattern B:</strong> Live canvas/boards where every change is sent over WebSocket and saved in real time. Server stores in Redis (or DB) and broadcasts so all clients stay in sync.
        </p>
    </div>

    <!-- Debounce Pattern -->
    <div class="local-code-example">
        <h3>‚è±Ô∏è Pattern: Debounce Text Input</h3>
        <p>For text fields, debounce so you send one update after typing pauses (e.g. 200ms):</p>

        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>// data: textDebounce: {}
updateNoteText(note, event) {
    const text = String(event.target?.value ?? note.text).slice(0, 500);
    if (text === note.text) return;
    const id = note.id;
    if (this.textDebounce[id]) clearTimeout(this.textDebounce[id].timer);
    this.textDebounce[id] = {
        text,
        timer: setTimeout(() => {
            if (this.notesWs?.isConnected() && this.textDebounce[id]) {
                this.notesWs.send({ type: 'note-update', username: this.notesUsername(), id, text: this.textDebounce[id].text });
                delete this.textDebounce[id];
            }
        }, 200)
    };
}</pre></div>

        <p class="jp-help-text jp-mt-15">
            üí° <strong>Debounce vs throttle:</strong> Debounce = run once after activity stops (good for text). Throttle = run at most every N ms (good for mouse move).
        </p>
        <p class="jp-help-text jp-mt-10">
            ‚ö†Ô∏è When using debounce with Pattern B, you must skip applying incoming <code>note-updated</code> while the user is typing ‚Äî see <strong>Handling note-updated (avoid echo overwrite)</strong> in the Pattern B section above.
        </p>
    </div>

    <!-- Throttling Pattern -->
    <div class="local-code-example">
        <h3>‚è±Ô∏è Pattern: Mouse/Position Throttling</h3>
        <p>Essential for high-frequency events like mouse movement:</p>

        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>class MyComponent {
    data() {
        return {
            ws: null,
            _lastSend: 0  // Track last send time
        };
    },

    methods: {
        handleMouseMove(event) {
            if (!this.ws || !this.ws.isConnected()) return;

            // Get mouse position
            const rect = event.currentTarget.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            // Throttle: only send every 50ms
            const now = Date.now();
            if (now - this._lastSend >= 50) {
                this._lastSend = now;

                this.ws.send({
                    type: 'cursor-move',
                    x: Math.round(x * 10) / 10,  // Round to 1 decimal
                    y: Math.round(y * 10) / 10
                });
            }
        }
    }
}</pre></div>

        <p class="jp-help-text jp-mt-15">
            üí° <strong>Important:</strong> Mouse events fire hundreds of times per second. Always throttle
            or debounce high-frequency events before sending over WebSocket!
        </p>
    </div>

    <!-- Error Handling -->
    <div class="local-code-example">
        <h3>üõ°Ô∏è Pattern: Error Handling & Reconnection</h3>
        <p>Handle connection failures gracefully:</p>

        <div class="jp-source-code" data-lang="javascript" data-show-lang="true"><pre>const ws = jPulse.ws.connect('/api/1/ws/my-app', {
    reconnectBaseInterval: 5000,    // Start with 5 seconds
    reconnectMaxInterval: 30000,    // Max 30 seconds
    maxReconnectAttempts: 10        // Give up after 10 attempts
})
.onStatusChange((status, oldStatus) => {
    if (status === 'disconnected') {
        // Show warning to user
        jPulse.UI.toast.show('Connection lost. Please reload page.', 'error');

        // Disable features that require WebSocket
        this.disableRealtimeFeatures();

    } else if (status === 'connected' && oldStatus === 'reconnecting') {
        // Reconnected!
        jPulse.UI.toast.show('Connection restored!', 'success');

        // Re-enable features
        this.enableRealtimeFeatures();

        // Optionally: reload fresh data
        await this.loadTodos();
    }
});</pre></div>
    </div>

    <!-- Message Format -->
    <div class="local-code-example">
        <h3>üì¶ Message Format Convention</h3>
        <p>All WebSocket messages follow the standard API format:</p>

        <h4>Success Response (wire envelope)</h4>
        <div class="jp-source-code" data-lang="json" data-show-lang="true"><pre>{
    "success": true,
    "data": {
        "type": "chat-message",
        "data": { "message": "Hello!", "timestamp": 1677123456789 },
        "ctx": { "username": "john_doe", "ip": "1.2.3.4" }
    }
}</pre></div>
        <p class="jp-help-text jp-mt-10 jp-mb-0">
            Payload convention: <code>type</code> + <code>data</code> (event-specific body). <code>ctx</code> (username, ip, etc.) is added by the framework.
        </p>

        <h4>Error Response</h4>
        <div class="jp-source-code" data-lang="json" data-show-lang="true"><pre>{
    "success": false,
    "error": "Authentication required",
    "code": 401
}</pre></div>

        <p class="jp-help-text jp-mt-15">
            üí° In your handler use <code>message.success</code>, <code>payload = message.data ?? {}</code> for the app payload (type, data, ctx); on failure use <code>message.error</code> and <code>message.code</code>.
        </p>
    </div>

    <!-- Common Patterns Summary -->
    <div class="jp-output jp-output-info jp-mt-30">
        <h3>üìö Quick Reference</h3>

        <table class="jp-table">
            <thead>
                <tr>
                    <th>Task</th>
                    <th>Code</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Configure UUID storage</td>
                    <td><code>jPulse.ws.configure({ uuidStorage: 'session' })</code></td>
                </tr>
                <tr>
                    <td>Connect</td>
                    <td><code>jPulse.ws.connect('/api/1/ws/path')</code></td>
                </tr>
                <tr>
                    <td>Send message</td>
                    <td><code>ws.send({type: 'action', data: ...})</code></td>
                </tr>
                <tr>
                    <td>Listen for messages</td>
                    <td><code>ws.onMessage((msg) => { if (msg.success) use msg.data; })</code></td>
                </tr>
                <tr>
                    <td>Check status</td>
                    <td><code>ws.getStatus() // 'connected', etc.</code></td>
                </tr>
                <tr>
                    <td>Check if connected</td>
                    <td><code>ws.isConnected() // boolean</code></td>
                </tr>
                <tr>
                    <td>Disconnect</td>
                    <td><code>ws.disconnect()</code></td>
                </tr>
                <tr>
                    <td>Broadcast (server)</td>
                    <td><code>ns.broadcast({ type, data }, ctx)</code></td>
                </tr>
                <tr>
                    <td>Send to one (server)</td>
                    <td><code>ns.sendToClient(clientId, { type, data }, ctx)</code></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="jp-output jp-output-warning jp-mt-30">
        <h3>üìñ Complete Documentation</h3>
        <p class="jp-m-0">
            For comprehensive API reference, advanced patterns, authentication, and troubleshooting,
            see the <a href="/jpulse-docs/websockets" target="_blank">WebSocket Documentation</a>.
        </p>
    </div>

    <!-- UUID Storage Configuration -->
    <div class="jp-output jp-output-success jp-mt-30">
        <h3>üÜî UUID Storage Modes</h3>

        <table class="jp-table">
            <thead>
                <tr>
                    <th>Mode</th>
                    <th>Scope</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>session</code> (default)</td>
                    <td>Per-tab, survives page reloads</td>
                    <td>Multi-tab collaborative apps</td>
                </tr>
                <tr>
                    <td><code>local</code></td>
                    <td>Per-browser, persistent identity</td>
                    <td>User identity across sessions</td>
                </tr>
                <tr>
                    <td><code>memory</code></td>
                    <td>Per-page load, no persistence</td>
                    <td>Testing, maximum isolation</td>
                </tr>
            </tbody>
        </table>

        <p class="jp-text-muted jp-mt-15 jp-mb-0">
            üí° <strong>Tip:</strong> Configure UUID storage before making any WebSocket connections.
            The <code>session</code> mode (default) enables multiple tabs to connect simultaneously
            to collaborative real-time applications.
        </p>
    </div>
</div>
`,

    mounted() {
        // Initialize jPulse source code components after Vue renders the template
        this.$nextTick(() => {
            jPulse.UI.sourceCode.initAll();
        });
    }

    // No props needed - static content only
};

// EOF site/webapp/view/hello-websocket/templates/code-examples.tmpl
