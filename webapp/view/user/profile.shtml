<!DOCTYPE html>
<!--
 * @name            jPulse Framework / WebApp / View / User Profile
 * @tagline         User profile view with edit capabilities
 * @description     User profile management with view and edit modes
 * @file            webapp/view/user/profile.shtml
 * @version         1.4.3
 * @release         2026-01-03
 * @repository      https://github.com/jpulse-net/jpulse-framework
 * @author          Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @copyright       2025 Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @license         BSL 1.1 -- see LICENSE file; for commercial use: team@jpulse.net
 * @genai           60%, Cursor 2.0, Claude Sonnet 4.5
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{i18n.view.user.profile.title}} - {{app.site.shortName}}</title>

    {{file.include "jpulse-header.tmpl"}}
    <style>
        /* Page-specific profile styles only */
        .local-profile-header {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #007acc;
        }

        .local-profile-info h1 {
            margin: 0;
            color: #333;
        }

        .local-profile-info .jp-user-details {
            color: #666;
            margin: 5px 0;
        }

        .local-profile-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .local-profile-section h3 {
            margin-top: 0;
            color: #007acc;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }

        .local-profile-section h3.local-no-content-header {
            margin-bottom: -5px;
            border-bottom: 0 none;
            padding-bottom: 0;
        }

        .local-user-profile .jp-read-only-field {
            background: #f8f9fa;
            color: #6c757d;
        }

        /* W-107: Plugin card styles */
        .local-plugin-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid transparent;
        }

        .local-plugin-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .local-plugin-card-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .local-plugin-card-title h3 {
            margin: 0;
            color: #007acc;
        }

        .local-plugin-card-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .local-plugin-card-description {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .local-plugin-field-grid {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 10px 15px;
        }

        .local-plugin-field-label {
            color: #555;
            font-weight: 500;
        }

        .local-plugin-field-value {
            color: #333;
        }

        .local-plugin-badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .local-plugin-badge-success {
            background: #d4edda;
            color: #155724;
        }

        .local-plugin-badge-danger {
            background: #f8d7da;
            color: #721c24;
        }

        .local-plugin-badge-warning {
            background: #fff3cd;
            color: #856404;
        }

        .local-plugin-badge-info {
            background: #cce5ff;
            color: #004085;
        }
    </style>
</head>
<body>
    <div class="jp-main">
      {{#if user.isAuthenticated}}
        <div class="jp-container-800 local-user-profile">
            <div class="local-profile-header">
                <div class="jp-user-avatar-large">
                    {{user.initials}}
                </div>
                <div class="local-profile-info">
                    <h1>{{user.firstName}} {{user.lastName}}</h1>
                    <div class="jp-user-details">@{{user.username}} ‚Ä¢ {{user.email}}</div>
                    <div class="jp-user-details">
                        <span class="jp-status-badge jp-status-{{user.status}}">{{user.status}}</span>
                    </div>
                </div>
            </div>

            <div class="local-profile-section">
                <h3>{{i18n.view.user.profile.personalInfo}}</h3>
                <form id="profileForm" class="jp-form">
                    <div class="jp-form-grid">
                        <div class="jp-form-group">
                            <label for="firstName" class="jp-form-label">{{i18n.view.user.profile.firstName}}</label>
                            <input type="text" id="firstName" name="firstName" class="jp-form-input jp-read-only-field" value="{{user.firstName}}" readonly>
                        </div>
                        <div class="jp-form-group">
                            <label for="lastName" class="jp-form-label">{{i18n.view.user.profile.lastName}}</label>
                            <input type="text" id="lastName" name="lastName" class="jp-form-input jp-read-only-field" value="{{user.lastName}}" readonly>
                        </div>
                    </div>
                    <div class="jp-form-grid">
                        <div class="jp-form-group">
                            <label for="nickName" class="jp-form-label">{{i18n.view.user.profile.nickName}}</label>
                            <input type="text" id="nickName" name="nickName" class="jp-form-input jp-read-only-field" value="{{user.nickName}}" readonly>
                        </div>
                        <div class="jp-form-group">
                            <label for="email" class="jp-form-label">{{i18n.view.user.profile.email}}</label>
                            <input type="email" id="email" name="email" class="jp-form-input jp-read-only-field" value="{{user.email}}" readonly>
                        </div>
                    </div>
                </form>
            </div>

            <div class="local-profile-section">
                <h3>{{i18n.view.user.profile.preferences}}</h3>
                <form id="preferencesForm" class="jp-form">
                    <div class="jp-form-grid">
                        <div class="jp-form-group">
                            <label for="language" class="jp-form-label">{{i18n.view.user.profile.language}}</label>
                            <select id="language" name="language" class="jp-form-select" disabled>
                                <!-- Options will be replaced dynamically -->
                                <option value="{{user.preferences.language}}" disabled selected>{{user.preferences.language}}</option>
                            </select>

                            <label for="theme" class="jp-form-label">{{i18n.view.user.profile.theme}}</label>
                            <select id="theme" name="theme" class="jp-form-select" disabled>
                                <!-- Options will be replaced dynamically -->
                                <option value="{{user.preferences.theme}}" disabled selected>{{user.preferences.theme}}</option>
                            </select>
                        </div>
                    </div>
                </form>
            </div>

            <div class="local-profile-section jp-view-mode-only">
                <h3 class="local-no-content-header">{{i18n.view.user.profile.security}}</h3>
            </div>

            <div id="securitySection" class="jp-collapsible jp-edit-mode-only">
                <h3>{{i18n.view.user.profile.security}}</h3>
                <div class="jp-collapsible-content">
                    <div class="jp-alert jp-alert-info">
                        {{i18n.view.user.profile.securityNote}}
                    </div>

                    <!-- Password fields (shown when section is expanded in edit mode) -->
                    <div id="passwordFields" class="jp-hidden jp-password-form">
                        <div class="jp-form-group">
                            <label for="currentPassword" class="jp-form-label">{{i18n.view.user.profile.currentPassword}}</label>
                            <input type="password" id="currentPassword" name="currentPassword" class="jp-form-input">
                        </div>
                        <div class="jp-form-grid">
                            <div class="jp-form-group">
                                <label for="newPassword" class="jp-form-label">{{i18n.view.user.profile.newPassword}}</label>
                                <input type="password" id="newPassword" name="newPassword" class="jp-form-input">
                            </div>
                            <div class="jp-form-group">
                                <label for="confirmPassword" class="jp-form-label">{{i18n.view.user.profile.confirmPassword}}</label>
                                <input type="password" id="confirmPassword" name="confirmPassword" class="jp-form-input">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- W-107: Plugin Cards Container (data-driven) -->
            <div id="pluginCardsContainer">
                <!-- Plugin cards will be rendered dynamically based on schema extensions -->
            </div>

            <div class="jp-btn-group">
                <button id="editBtn" class="jp-btn jp-btn-primary" onclick="toggleEditMode()">{{i18n.view.user.profile.edit}}</button>
                <button id="saveBtn" class="jp-btn jp-btn-success jp-hidden" onclick="saveProfile()">{{i18n.view.user.profile.save}}</button>
                <button id="cancelBtn" class="jp-btn jp-btn-secondary jp-hidden" onclick="cancelEdit()">{{i18n.view.user.profile.cancel}}</button>
            </div>
        </div>
      {{else}}
        <div class="jp-error-box">
            {{i18n.view.auth.common.notAuthenticated}}
        </div>
      {{/if}}
    </div>

    <script>
        {{#if user.isAuthenticated}}
        let editMode = false;
        let originalValues = {};
        let schemaMetadata = {};  // W-107: Schema extensions metadata
        let currentUserData = {}; // W-107: Current user data for plugin cards
        let pluginConfig = {};    // W-107: Plugin config from database

        // Warn user when navigating away with unsaved changes
        window.addEventListener('beforeunload', (event) => {
            // Only warn if in edit mode AND there are actual changes
            if (editMode && hasFormChanges()) {
                event.preventDefault();
                // Modern browsers ignore custom messages and show their own generic prompt
                // Setting returnValue to any truthy value triggers the dialog
                event.returnValue = true;
                return true;
            }
        });

        // Enhanced profile management using jPulse utilities
        let securityCollapsible = null;

        jPulse.dom.ready(async () => {
            await loadProfile();
            await loadLanguages();
            await loadThemes();

            // Register the collapsible security section with handle
            securityCollapsible = jPulse.UI.collapsible.register('securitySection', {
                initOpen: false,
                onOpen: () => {
                    // Show password fields when opened
                    const passwordFields = document.getElementById('passwordFields');
                    jPulse.dom.show(passwordFields);
                },
                onClose: () => {
                    // Hide password fields and clear them when closed
                    const passwordFields = document.getElementById('passwordFields');
                    jPulse.dom.hide(passwordFields);
                    ['currentPassword', 'newPassword', 'confirmPassword'].forEach(id => {
                        document.getElementById(id).value = '';
                    });
                }
            });
        });

        function toggleEditMode() {
            editMode = !editMode;
            const editBtn = document.getElementById('editBtn');
            const saveBtn = document.getElementById('saveBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const passwordFields = document.getElementById('passwordFields');

            if (editMode) {
                // Add edit mode class to container to show/hide sections
                const container = document.querySelector('.jp-container-800');
                container.classList.add('jp-edit-mode');

                // Ensure security section starts collapsed when entering edit mode
                if (securityCollapsible && securityCollapsible.isExpanded()) {
                    securityCollapsible.collapse();
                }

                // Store original values at edit start (deep copy for comparison)
                originalValues = JSON.parse(JSON.stringify(getCurrentFormValues()));

                // Enable editing for profile fields
                ['firstName', 'lastName', 'nickName'].forEach(id => {
                    const field = document.getElementById(id);
                    field.readOnly = false;
                    field.classList.remove('jp-read-only-field');
                });

                // Enable editing for preference fields
                ['language', 'theme'].forEach(id => {
                    const field = document.getElementById(id);
                    field.disabled = false;
                    field.classList.remove('jp-read-only-field');
                });

                // Update buttons
                jPulse.dom.hide(editBtn);
                jPulse.dom.show(saveBtn);
                jPulse.dom.show(cancelBtn);
            } else {
                cancelEdit();
            }
        }

        // Get current form values as an object (for comparison)
        function getCurrentFormValues() {
            const values = {
                firstName: document.getElementById('firstName').value,
                lastName: document.getElementById('lastName').value,
                nickName: document.getElementById('nickName').value,
                language: document.getElementById('language').value,
                theme: document.getElementById('theme').value
            };
            // Include plugin data
            for (const key of Object.keys(schemaMetadata)) {
                if (currentUserData[key] !== undefined) {
                    values[key] = currentUserData[key];
                }
            }
            return values;
        }

        function hasFormChanges() {
            return !jPulse.utils.deepEqual(getCurrentFormValues(), originalValues);
        }

        async function cancelEdit() {
            // Check if form has actual changes (only show dialog if there are changes)
            if (editMode && hasFormChanges()) {
                const result = await jPulse.UI.confirmDialog({
                    title: `{{i18n.view.user.profile.discardChangesTitle}}`,
                    message: `{{i18n.view.user.profile.discardChangesMessage}}`,
                    buttons: [`{{i18n.view.user.profile.backToEdit}}`, `{{i18n.view.user.profile.discardChanges}}`]
                });
                if (result.button === `{{i18n.view.user.profile.backToEdit}}`) {
                    return;
                }
            }

            editMode = false;

            // Remove edit mode class from container
            const container = document.querySelector('.jp-container-800');
            container.classList.remove('jp-edit-mode');

            // Restore original values
            Object.keys(originalValues).forEach(key => {
                const field = document.getElementById(key);
                if (field) {
                    field.value = originalValues[key];
                }
            });

            // Disable editing for profile fields
            ['firstName', 'lastName', 'nickName'].forEach(id => {
                const field = document.getElementById(id);
                field.readOnly = true;
                field.classList.add('jp-read-only-field');
            });

            // Disable editing for preference fields
            ['language', 'theme'].forEach(id => {
                const field = document.getElementById(id);
                field.disabled = true;
                field.classList.add('jp-read-only-field');
            });

            // Hide password fields and clear them
            jPulse.dom.hide(document.getElementById('passwordFields'));
            ['currentPassword', 'newPassword', 'confirmPassword'].forEach(id => {
                document.getElementById(id).value = '';
            });

            // Update buttons
            jPulse.dom.show(document.getElementById('editBtn'));
            jPulse.dom.hide(document.getElementById('saveBtn'));
            jPulse.dom.hide(document.getElementById('cancelBtn'));
        }

        async function saveProfile() {
            // Check if user wants to change password (security section expanded and password fields filled)
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            const isChangingPassword = securityCollapsible && securityCollapsible.isExpanded() &&
                                     (currentPassword || newPassword || confirmPassword);

            // Prepare profile and preferences data
            const profileData = {
                profile: {
                    firstName: document.getElementById('firstName').value,
                    lastName: document.getElementById('lastName').value,
                    nickName: document.getElementById('nickName').value
                },
                preferences: {
                    language: document.getElementById('language').value,
                    theme: document.getElementById('theme').value
                }
            };

            // W-107: Include plugin data from schema extensions
            for (const blockKey of Object.keys(schemaMetadata)) {
                if (currentUserData[blockKey] !== undefined) {
                    profileData[blockKey] = currentUserData[blockKey];
                }
            }

            try {
                // Always save profile and preferences first
                const profileResult = await jPulse.api.put('/api/1/user', profileData);

                if (!profileResult.success) {
                    jPulse.UI.toast.error(profileResult.error || `{{i18n.view.user.profile.failedToUpdateProfile}}`);
                    return;
                }

                // If user wants to change password, handle that too
                if (isChangingPassword) {

                    // Validate password fields
                    if (!currentPassword || !newPassword || !confirmPassword) {
                        jPulse.UI.toast.error(`{{i18n.view.user.profile.allPasswordFieldsRequired}}`);
                        return;
                    }

                    if (newPassword !== confirmPassword) {
                        jPulse.UI.toast.error(`{{i18n.view.user.profile.passwordsDoNotMatch}}`);
                        return;
                    }

                    if (newPassword.length < 8) {
                        jPulse.UI.toast.error(`{{i18n.view.user.profile.passwordTooShort}}`);
                        return;
                    }

                    // Save password
                    const passwordData = {
                        currentPassword: currentPassword,
                        newPassword: newPassword
                    };

                    const passwordResult = await jPulse.api.put('/api/1/user/password', passwordData);

                    if (!passwordResult.success) {
                        jPulse.UI.toast.error(passwordResult.error || `{{i18n.view.user.profile.failedToUpdatePassword}}`);
                        return;
                    }
                }

                // Success - show appropriate message
                const successMessage = isChangingPassword
                    ? `{{i18n.view.user.profile.profileAndPasswordUpdatedSuccess}}`
                    : `{{i18n.view.user.profile.profileUpdatedSuccess}}`;

                jPulse.UI.toast.success(successMessage);

                // Exit edit mode and reload data
                editMode = false;
                cancelEdit();
                await loadProfile();

            } catch (error) {
                jPulse.UI.toast.error(`{{i18n.view.user.profile.networkError}}`.replace('%ERROR%', error.message));
            }
        }

        async function loadProfile() {
            try {
                // W-107: Request user data with schema extensions metadata
                const result = await jPulse.api.get('/api/1/user?includeSchema=1');
                if (result.success && result.data) {
                    const user = result.data;
                    currentUserData = user;  // W-107: Store for plugin cards

                    // W-107: Store schema metadata if provided
                    if (result.schema) {
                        schemaMetadata = result.schema;
                    }

                    // Update form fields
                    document.getElementById('firstName').value = user.profile?.firstName || '';
                    document.getElementById('lastName').value = user.profile?.lastName || '';
                    document.getElementById('nickName').value = user.profile?.nickName || '';
                    document.getElementById('email').value = user.email || '';

                    // Update preferences
                    document.getElementById('language').value = user.preferences?.language || `{{appConfig.utils.i18n.default}}` || 'en';
                    document.getElementById('theme').value = user.preferences?.theme || 'light';

                    // Update status badge
                    const statusBadge = document.querySelector('.jp-status-badge');
                    if (statusBadge && user.status) {
                        statusBadge.textContent = user.status;
                        statusBadge.className = `jp-status-badge jp-status-${user.status}`;
                    }

                    // W-107: Render plugin cards based on schema
                    await loadPluginConfig();
                    renderPluginCards();
                } else {
                    jPulse.UI.toast.error(result.error || `{{i18n.view.user.profile.failedToLoadProfile}}`);
                }
            } catch (error) {
                jPulse.UI.toast.error(`{{i18n.view.user.profile.networkErrorLoadingProfile}}`.replace('%ERROR%', error.message));
            }
        }

        // W-107: Load plugin configuration from database
        // TODO: Implement proper /api/1/plugin/config endpoint in future
        async function loadPluginConfig() {
            // For now, plugin config-based showIf conditions will use empty config
            // This means actions with showIf: { config: '...' } will default to hidden
            pluginConfig = {};
        }

        // W-107: Render plugin cards based on schema extensions
        function renderPluginCards() {
            const container = document.getElementById('pluginCardsContainer');
            container.innerHTML = '';

            if (!schemaMetadata || Object.keys(schemaMetadata).length === 0) {
                return;
            }

            // Sort plugins by order - use userCard for user's own profile
            const sortedBlocks = Object.entries(schemaMetadata)
                .filter(([key, blockDef]) => blockDef._meta?.userCard?.visible)
                .sort((a, b) => (a[1]._meta?.userCard?.order || 999) - (b[1]._meta?.userCard?.order || 999));

            sortedBlocks.forEach(([blockKey, blockDef]) => {
                const cardConfig = blockDef._meta.userCard;
                const cardHtml = renderPluginCard(blockKey, blockDef, cardConfig);
                container.insertAdjacentHTML('beforeend', cardHtml);
            });
        }

        // W-107: Render a single plugin card
        function renderPluginCard(blockKey, blockDef, cardConfig) {
            const userData = currentUserData[blockKey] || {};
            const bgColor = cardConfig.backgroundColor || '#f8f9fa';
            const icon = cardConfig.icon || 'üì¶';
            const label = cardConfig.label || blockKey;
            const description = cardConfig.description || '';

            // Build action buttons
            const actionsHtml = renderCardActions(blockKey, cardConfig.actions || [], userData);

            // Build fields display - use userCard visibility
            const fieldsHtml = renderCardFields(blockKey, blockDef, userData);

            return `
                <div class="local-plugin-card" id="card-${blockKey}" style="background-color: ${bgColor}; border-color: ${bgColor === '#f8f9fa' ? 'transparent' : bgColor};">
                    <div class="local-plugin-card-header">
                        <div class="local-plugin-card-title">
                            <span class="local-plugin-icon">${icon}</span>
                            <h3>${label}</h3>
                        </div>
                        <div class="local-plugin-card-actions">
                            ${actionsHtml}
                        </div>
                    </div>
                    ${description ? `<div class="local-plugin-card-description">${description}</div>` : ''}
                    <div class="local-plugin-field-grid">
                        ${fieldsHtml}
                    </div>
                </div>
            `;
        }

        // W-107: Render card action buttons
        function renderCardActions(blockKey, actions, userData) {
            if (!actions || actions.length === 0) return '';

            return actions
                .filter(action => evaluateShowIf(action.showIf, userData, blockKey))
                .map(action => {
                    const style = action.style || 'secondary';
                    const icon = action.icon ? `${action.icon} ` : '';
                    const btnClass = `jp-btn jp-btn-${style} jp-btn-sm`;
                    return `<button class="${btnClass}" onclick="handlePluginAction('${blockKey}', ${JSON.stringify(action).replace(/'/g, "\\'").replace(/"/g, '&quot;')})">${icon}${action.label}</button>`;
                })
                .join('');
        }

        // W-107: Evaluate showIf condition
        function evaluateShowIf(showIf, userData, blockKey) {
            if (!showIf) return true;

            // Simple conditions
            if (showIf === 'always') return true;
            if (showIf === 'hasValue') return false; // For action buttons, default to true if no showIf

            // Field-based condition: { field: 'mfa.enabled', equals: true }
            if (showIf.field) {
                let value = getNestedValue(currentUserData, showIf.field);

                // Apply default from schema if value is undefined
                if (value === undefined) {
                    const parts = showIf.field.split('.');
                    if (parts.length >= 2) {
                        const schemaBlock = schemaMetadata[parts[0]];
                        const fieldDef = schemaBlock?.[parts[1]];
                        if (fieldDef?.default !== undefined) {
                            value = fieldDef.default;
                        }
                    }
                }

                if (showIf.equals !== undefined) {
                    return value === showIf.equals;
                }
                if (showIf.condition === 'exists') {
                    return value !== null && value !== undefined;
                }
                if (showIf.condition === 'gt' && showIf.value !== undefined) {
                    return value > showIf.value;
                }
                return false;
            }

            // Config-based condition: { config: 'auth-mfa.allowUserDisable', equals: true }
            if (showIf.config) {
                const value = getNestedValue(pluginConfig, showIf.config);
                return value === showIf.equals;
            }

            // All condition: { all: [...conditions] }
            if (showIf.all && Array.isArray(showIf.all)) {
                return showIf.all.every(cond => evaluateShowIf(cond, userData, blockKey));
            }

            // Any condition: { any: [...conditions] }
            if (showIf.any && Array.isArray(showIf.any)) {
                return showIf.any.some(cond => evaluateShowIf(cond, userData, blockKey));
            }

            return true;
        }

        // W-107: Get nested value from object using dot notation
        function getNestedValue(obj, path) {
            if (!obj || !path) return undefined;
            return path.split('.').reduce((acc, part) => acc?.[part], obj);
        }

        // W-107: Set nested value in object using dot notation
        function setNestedValue(obj, path, value) {
            const parts = path.split('.');
            const last = parts.pop();
            const target = parts.reduce((acc, part) => {
                if (acc[part] === undefined) acc[part] = {};
                return acc[part];
            }, obj);
            target[last] = value;
        }

        // W-107: Render card fields (using userCard visibility)
        function renderCardFields(blockKey, blockDef, userData) {
            const fields = [];

            for (const [fieldKey, fieldDef] of Object.entries(blockDef)) {
                if (fieldKey === '_meta') continue;
                if (!fieldDef.userCard?.visible) continue;  // Use userCard for user profile

                // Get value with fallback to default from schema
                let value = userData[fieldKey];
                if (value === undefined && fieldDef.default !== undefined) {
                    value = fieldDef.default;
                }

                // Check showIf
                const showIf = fieldDef.showIf;
                if (showIf === 'hasValue' && (value === null || value === undefined)) {
                    continue;
                }
                if (typeof showIf === 'object' && !evaluateShowIf(showIf, userData, blockKey)) {
                    continue;
                }

                const label = fieldDef.label || fieldKey;
                const displayValue = formatFieldValue(value, fieldDef);

                fields.push(`
                    <div class="local-plugin-field-label">${label}:</div>
                    <div class="local-plugin-field-value">${displayValue}</div>
                `);
            }

            return fields.join('');
        }

        // W-107: Format field value based on displayAs
        function formatFieldValue(value, fieldDef) {
            const displayAs = fieldDef.displayAs;

            if (value === null || value === undefined) {
                return '<span style="color: #999;">‚Äî</span>';
            }

            switch (displayAs) {
                case 'badge':
                    if (typeof value === 'boolean') {
                        const badgeClass = value ? 'local-plugin-badge-success' : 'local-plugin-badge-danger';
                        const badgeText = value ? '‚úÖ Enabled' : '‚ùå Disabled';
                        return `<span class="local-plugin-badge ${badgeClass}">${badgeText}</span>`;
                    }
                    return `<span class="local-plugin-badge local-plugin-badge-info">${value}</span>`;

                case 'date':
                    if (!value) return '<span style="color: #999;">‚Äî</span>';
                    return new Date(value).toLocaleDateString();

                case 'datetime':
                    if (!value) return '<span style="color: #999;">‚Äî</span>';
                    return new Date(value).toLocaleString();

                case 'count':
                    if (Array.isArray(value)) {
                        return `${value.length} remaining`;
                    }
                    return String(value);

                default:
                    if (typeof value === 'boolean') {
                        return value ? 'Yes' : 'No';
                    }
                    if (Array.isArray(value)) {
                        return value.join(', ');
                    }
                    return String(value);
            }
        }

        // W-107: Handle plugin action button click
        async function handlePluginAction(blockKey, action) {
            // Parse action if it's a string (from HTML attribute)
            if (typeof action === 'string') {
                action = JSON.parse(action.replace(/&quot;/g, '"'));
            }

            // Show confirmation dialog if required
            if (action.confirm) {
                const result = await jPulse.UI.confirmDialog({
                    title: action.label,
                    message: action.confirm,
                    buttons: ['Cancel', 'Continue']
                });
                if (result.button !== 'Continue') return;
            }

            // Handle different action types
            if (action.setFields) {
                // Enter edit mode FIRST to capture original values before modification
                if (!editMode) {
                    toggleEditMode();
                }

                // Apply setFields to currentUserData (local modification)
                for (const [path, value] of Object.entries(action.setFields)) {
                    setNestedValue(currentUserData, path, value);
                }

                // Re-render the card
                renderPluginCards();

                // Show toast
                if (action.toast) {
                    jPulse.UI.toast.info(action.toast);
                }
            } else if (action.navigate) {
                // Check for unsaved changes
                if (editMode) {
                    const result = await jPulse.UI.confirmDialog({
                        title: `{{i18n.view.user.profile.unsavedChangesTitle}}`,
                        message: `{{i18n.view.user.profile.unsavedChangesMessage}}`,
                        buttons: [`{{i18n.view.user.profile.cancel}}`, `{{i18n.view.user.profile.saveAndContinue}}`]
                    });
                    if (result.button === `{{i18n.view.user.profile.cancel}}`) return;
                    await saveProfile();
                }
                window.location.href = action.navigate;
            } else if (action.handler) {
                // Call registered handler
                const handler = window.jPulse?.schemaHandlers?.[action.handler];
                if (handler) {
                    const result = await handler(currentUserData, action);
                    if (result?.refresh) {
                        await loadProfile();
                    }
                } else {
                    console.error(`- jPulse: Handler not found: ${action.handler}`);
                    jPulse.UI.toast.error(`Handler not available: ${action.handler}`);
                }
            }
        }

        async function loadLanguages() {
            try {
                const response = await jPulse.api.get('/api/1/auth/languages');

                if (response.success) {
                    const languageSelect = document.getElementById('language');
                    const currentValue = languageSelect.value;

                    languageSelect.innerHTML = '';

                    const languages = response.data;
                    if (Array.isArray(languages)) {
                        languages.forEach(([code, name]) => {
                            const option = document.createElement('option');
                            option.value = code;
                            option.textContent = name;
                            languageSelect.appendChild(option);
                        });
                    } else {
                        console.error('- jPulse: Languages data is not an array:', languages);
                        jPulse.UI.toast.error('Invalid language data format received from server');
                    }

                    languageSelect.value = currentValue;
                } else {
                    jPulse.UI.toast.error('Failed to load language options: ' + (response.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('- jPulse: Failed to load languages:', error);
                jPulse.UI.toast.error('Failed to load language options. Please refresh the page.');
            }
        }

        async function loadThemes() {
            try {
                const response = await jPulse.api.get('/api/1/user/enums?fields=preferences.theme');

                if (response.success && response.data && response.data['preferences.theme']) {
                    const themeSelect = document.getElementById('theme');
                    const currentValue = themeSelect.value;

                    themeSelect.innerHTML = '';

                    const themes = response.data['preferences.theme'];
                    if (Array.isArray(themes)) {
                        themes.forEach(theme => {
                            const option = document.createElement('option');
                            option.value = theme;
                            option.textContent = theme;
                            themeSelect.appendChild(option);
                        });
                    } else {
                        console.error('- jPulse: Themes data is not an array:', themes);
                        jPulse.UI.toast.error('Invalid theme data format received from server');
                    }

                    themeSelect.value = currentValue;
                } else {
                    jPulse.UI.toast.error('Failed to load theme options: ' + (response.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('- jPulse: Failed to load themes:', error);
                jPulse.UI.toast.error('Failed to load theme options. Please refresh the page.');
            }
        }
        {{/if}}
    </script>

    {{file.include "jpulse-footer.tmpl"}}
</body>
</html>
