<!-- Start webapp/view/user/settings.tmpl -->
{{!--
 * @name            jPulse Framework / WebApp / View / User / Settings Template
 * @tagline         User SPA - Settings template
 * @description     W-134: Settings template of user profile Single Page Application
 * @file            webapp/view/user/settings.tmpl
 * @version         1.6.15
 * @release         2026-02-11
 * @repository      https://github.com/jpulse-net/jpulse-framework
 * @author          Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @copyright       2025-2026 Peter Thoeny, https://twiki.org & https://github.com/peterthoeny/
 * @license         BSL 1.1 -- see LICENSE file; for commercial use: team@jpulse.net
 * @genai           60%, Cursor 2.3, Claude Sonnet 4.5
--}}
{{#component "userSpa.settingsHtml"}}
{{#if user.isAuthenticated}}
    <div class="jp-container-800 local-user-profile">
        <div class="local-profile-header">
            <div class="jp-user-avatar-large">
                {{user.initials}}
            </div>
            <div class="local-profile-info">
                <h1>{{user.firstName}} {{user.lastName}}</h1>
                <div class="jp-user-details">@{{user.username}} ‚Ä¢ {{user.email}}</div>
                <div class="jp-user-details">
                    <span class="jp-status-badge jp-status-{{user.status}}">{{user.status}}</span>
                </div>
            </div>
        </div>

        <div class="jp-card local-profile-section">
            <h3>{{i18n.view.user.settings.personalInfo}}</h3>
            <form id="profileForm" class="jp-form">
                <div class="jp-form-grid">
                    <div class="jp-form-group">
                        <label for="firstName" class="jp-form-label">{{i18n.view.user.settings.firstName}}</label>
                        <input type="text" id="firstName" name="firstName" class="jp-form-input jp-read-only-field" value="{{user.firstName}}" readonly>
                    </div>
                    <div class="jp-form-group">
                        <label for="lastName" class="jp-form-label">{{i18n.view.user.settings.lastName}}</label>
                        <input type="text" id="lastName" name="lastName" class="jp-form-input jp-read-only-field" value="{{user.lastName}}" readonly>
                    </div>
                </div>
                <div class="jp-form-grid">
                    <div class="jp-form-group">
                        <label for="nickName" class="jp-form-label">{{i18n.view.user.settings.nickName}}</label>
                        <input type="text" id="nickName" name="nickName" class="jp-form-input jp-read-only-field" value="{{user.nickName}}" readonly>
                    </div>
                    <div class="jp-form-group">
                        <label for="email" class="jp-form-label">{{i18n.view.user.settings.email}}</label>
                        <input type="email" id="email" name="email" class="jp-form-input jp-read-only-field" value="{{user.email}}" readonly>
                    </div>
                </div>
            </form>
        </div>

        <div class="jp-card local-profile-section">
            <h3>{{i18n.view.user.settings.preferences}}</h3>
            <form id="preferencesForm" class="jp-form">
                <div class="jp-form-grid">
                    <div class="jp-form-group">
                        <label for="language" class="jp-form-label">{{i18n.view.user.settings.language}}</label>
                        <select id="language" name="language" class="jp-form-select" disabled>
                            <!-- Options will be replaced dynamically -->
                            <option value="{{string.default user.preferences.language "en"}}" disabled selected>{{string.default user.preferences.language "en"}}</option>
                        </select>

                        <label for="theme" class="jp-form-label">{{i18n.view.user.settings.theme}}</label>
                        <select id="theme" name="theme" class="jp-form-select" disabled>
                            <!-- Options will be replaced dynamically -->
                            <option value="{{string.default user.preferences.theme "light"}}" disabled selected>{{string.default user.preferences.theme "light"}}</option>
                        </select>
                    </div>
                </div>
            </form>
        </div>

        <div class="jp-card local-profile-section jp-view-mode-only">
            <h3 class="local-no-content-header">{{i18n.view.user.settings.security}}</h3>
        </div>

        <div id="securitySection" class="jp-collapsible jp-edit-mode-only">
            <h3>{{i18n.view.user.settings.security}}</h3>
            <div class="jp-collapsible-content">
                <div class="jp-alert jp-alert-info">
                    {{i18n.view.user.settings.securityNote}}
                </div>

                <!-- Password fields (shown when section is expanded in edit mode) -->
                <div id="passwordFields" class="jp-hidden jp-password-form">
                    <div class="jp-form-group">
                        <label for="currentPassword" class="jp-form-label">{{i18n.view.user.settings.currentPassword}}</label>
                        <input type="password" id="currentPassword" name="currentPassword" class="jp-form-input">
                    </div>
                    <div class="jp-form-grid">
                        <div class="jp-form-group">
                            <label for="newPassword" class="jp-form-label">{{i18n.view.user.settings.newPassword}}</label>
                            <input type="password" id="newPassword" name="newPassword" class="jp-form-input">
                        </div>
                        <div class="jp-form-group">
                            <label for="confirmPassword" class="jp-form-label">{{i18n.view.user.settings.confirmPassword}}</label>
                            <input type="password" id="confirmPassword" name="confirmPassword" class="jp-form-input">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- W-107: Plugin Cards Container (data-driven) -->
        <div id="pluginCardsContainer">
            <!-- Plugin cards will be rendered dynamically based on schema extensions -->
        </div>

        <div class="jp-btn-group">
            <button id="editBtn" class="jp-btn jp-btn-primary" onclick="toggleEditMode()">{{i18n.view.user.settings.edit}}</button>
            <button id="saveBtn" class="jp-btn jp-btn-success jp-hidden" onclick="saveProfile()">{{i18n.view.user.settings.save}}</button>
            <button id="cancelBtn" class="jp-btn jp-btn-secondary jp-hidden" onclick="cancelEdit()">{{i18n.view.user.settings.cancel}}</button>
        </div>
    </div>
{{else}}
    <div class="jp-error-box">
        {{i18n.view.auth.common.notAuthenticated}}
    </div>
{{/if}}
{{/component}}
{{#component "userSpa.settingsJs"}}
{{#if user.isAuthenticated}}
    // W-134: Settings page initialization function (called by SPA router)
    async function initSettings() {
        await loadSettingsProfile();
        await loadSettingsLanguages();
        await loadSettingsThemes();

        // Register the collapsible security section with handle
        securityCollapsible = jPulse.UI.collapsible.register('securitySection', {
            initOpen: false,
            onOpen: () => {
                // Show password fields when opened
                const passwordFields = document.getElementById('passwordFields');
                jPulse.dom.show(passwordFields);
            },
            onClose: () => {
                // Hide password fields and clear them when closed
                const passwordFields = document.getElementById('passwordFields');
                jPulse.dom.hide(passwordFields);
                ['currentPassword', 'newPassword', 'confirmPassword'].forEach(id => {
                    document.getElementById(id).value = '';
                });
            }
        });
    }

    let editMode = false;
    let originalValues = {};
    let schemaMetadata = {};  // W-107: Schema extensions metadata
    let currentUserData = {}; // W-107: Current user data for plugin cards
    let pluginConfig = {};    // W-107: Plugin config from database
    let originalThemePreview = null; // Theme before any preview changes in current edit session
    let securityCollapsible = null; // Collapsible handle

    const themeColorSchemes = (function buildThemeSchemeMap() {
        const map = {};
        {{#each appConfig.system.themes}}
            map['{{this.name}}'] = '{{this.colorScheme}}';
        {{/each}}
        return map;
    })();

    function applyThemePreview(themeId) {
        const id = String(themeId || '').trim();
        if (!id.match(/^[a-zA-Z0-9_-]+$/)) return;

        document.documentElement.setAttribute('data-theme', id);

        const themeLink = Array.from(document.querySelectorAll('link[rel="stylesheet"]'))
            .find(l => (l.getAttribute('href') || '').startsWith('/themes/') || (l.href || '').includes('/themes/'));

        if (themeLink) {
            themeLink.setAttribute('href', `/themes/${id}.css?t=${Date.now()}`);
        }

        const scheme = themeColorSchemes[id] || (id === 'dark' ? 'dark' : 'light');
        const prismLink = Array.from(document.querySelectorAll('link[rel="stylesheet"]'))
            .find(l => (l.getAttribute('href') || '').startsWith('/common/prism/prism-') || (l.href || '').includes('/common/prism/prism-'));

        if (prismLink && (scheme === 'light' || scheme === 'dark')) {
            prismLink.setAttribute('href', `/common/prism/prism-${scheme}.css?t=${Date.now()}`);
        }
    }

    // Warn user when navigating away with unsaved changes
    window.addEventListener('beforeunload', (event) => {
        // Only warn if in edit mode AND there are actual changes
        if (editMode && hasFormChanges()) {
            event.preventDefault();
            // Modern browsers ignore custom messages and show their own generic prompt
            // Setting returnValue to any truthy value triggers the dialog
            event.returnValue = true;
            return true;
        }
    });

    function toggleEditMode() {
        editMode = !editMode;
        const editBtn = document.getElementById('editBtn');
        const saveBtn = document.getElementById('saveBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const passwordFields = document.getElementById('passwordFields');

        if (editMode) {
            // Add edit mode class to container to show/hide sections
            const container = document.querySelector('.jp-container-800');
            container.classList.add('jp-edit-mode');

            // Ensure security section starts collapsed when entering edit mode
            if (securityCollapsible && securityCollapsible.isExpanded()) {
                securityCollapsible.collapse();
            }

            // Store original values at edit start (deep copy for comparison)
            originalValues = JSON.parse(JSON.stringify(getCurrentFormValues()));
            originalThemePreview = document.documentElement.getAttribute('data-theme') || (originalValues.theme || 'light');

            // Enable editing for profile fields
            ['firstName', 'lastName', 'nickName'].forEach(id => {
                const field = document.getElementById(id);
                field.readOnly = false;
                field.classList.remove('jp-read-only-field');
            });

            // Enable editing for preference fields
            ['language', 'theme'].forEach(id => {
                const field = document.getElementById(id);
                field.disabled = false;
                field.classList.remove('jp-read-only-field');
            });

            // W-129: Instant theme preview when changing the theme dropdown (no persistence until save)
            const themeSelect = document.getElementById('theme');
            if (themeSelect && !themeSelect.dataset.previewBound) {
                themeSelect.addEventListener('change', () => {
                    if (!editMode) return;
                    applyThemePreview(themeSelect.value);
                });
                themeSelect.dataset.previewBound = '1';
            }

            // Update buttons
            jPulse.dom.hide(editBtn);
            jPulse.dom.show(saveBtn);
            jPulse.dom.show(cancelBtn);
        } else {
            cancelEdit();
        }
    }

    // Get current form values as an object (for comparison)
    function getCurrentFormValues() {
        const values = {
            firstName: document.getElementById('firstName').value,
            lastName: document.getElementById('lastName').value,
            nickName: document.getElementById('nickName').value,
            language: document.getElementById('language').value,
            theme: document.getElementById('theme').value
        };
        // Include plugin data
        for (const key of Object.keys(schemaMetadata)) {
            if (currentUserData[key] !== undefined) {
                values[key] = currentUserData[key];
            }
        }
        return values;
    }

    function hasFormChanges() {
        return !jPulse.utils.deepEqual(getCurrentFormValues(), originalValues);
    }

    async function cancelEdit(options = {}) {
        const { revertTheme = true } = options;
        // Check if form has actual changes (only show dialog if there are changes)
        if (editMode && hasFormChanges()) {
            const result = await jPulse.UI.confirmDialog({
                title: `{{i18n.view.user.settings.discardChangesTitle}}`,
                message: `{{i18n.view.user.settings.discardChangesMessage}}`,
                buttons: [`{{i18n.view.user.settings.backToEdit}}`, `{{i18n.view.user.settings.discardChanges}}`]
            });
            if (result.button === `{{i18n.view.user.settings.backToEdit}}`) {
                return;
            }
        }

        editMode = false;

        // Remove edit mode class from container
        const container = document.querySelector('.jp-container-800');
        container.classList.remove('jp-edit-mode');

        // Restore original values
        Object.keys(originalValues).forEach(key => {
            const field = document.getElementById(key);
            if (field) {
                field.value = originalValues[key];
            }
        });

        // W-129: Revert any temporary theme preview changes
        if (revertTheme) {
            const themeField = document.getElementById('theme');
            const revertThemeId = themeField ? (themeField.value || originalThemePreview || 'light') : (originalThemePreview || 'light');
            applyThemePreview(revertThemeId);
        }

        // Disable editing for profile fields
        ['firstName', 'lastName', 'nickName'].forEach(id => {
            const field = document.getElementById(id);
            field.readOnly = true;
            field.classList.add('jp-read-only-field');
        });

        // Disable editing for preference fields
        ['language', 'theme'].forEach(id => {
            const field = document.getElementById(id);
            field.disabled = true;
            field.classList.add('jp-read-only-field');
        });

        // Hide password fields and clear them
        jPulse.dom.hide(document.getElementById('passwordFields'));
        ['currentPassword', 'newPassword', 'confirmPassword'].forEach(id => {
            document.getElementById(id).value = '';
        });

        // Update buttons
        jPulse.dom.show(document.getElementById('editBtn'));
        jPulse.dom.hide(document.getElementById('saveBtn'));
        jPulse.dom.hide(document.getElementById('cancelBtn'));
    }

    async function saveProfile() {
        // Check if user wants to change password (security section expanded and password fields filled)
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        const isChangingPassword = securityCollapsible && securityCollapsible.isExpanded() &&
                                 (currentPassword || newPassword || confirmPassword);

        // Prepare profile and preferences data
        const profileData = {
            profile: {
                firstName: document.getElementById('firstName').value,
                lastName: document.getElementById('lastName').value,
                nickName: document.getElementById('nickName').value
            },
            preferences: {
                language: document.getElementById('language').value,
                theme: document.getElementById('theme').value
            }
        };

        // W-107: Include plugin data from schema extensions
        for (const blockKey of Object.keys(schemaMetadata)) {
            if (currentUserData[blockKey] !== undefined) {
                profileData[blockKey] = currentUserData[blockKey];
            }
        }

        try {
            // Always save profile and preferences first
            const profileResult = await jPulse.api.put('/api/1/user', profileData);

            if (!profileResult.success) {
                jPulse.UI.toast.error(profileResult.error || `{{i18n.view.user.settings.failedToUpdateProfile}}`);
                return;
            }

            // If user wants to change password, handle that too
            if (isChangingPassword) {

                // Validate password fields
                if (!currentPassword || !newPassword || !confirmPassword) {
                    jPulse.UI.toast.error(`{{i18n.view.user.settings.allPasswordFieldsRequired}}`);
                    return;
                }

                if (newPassword !== confirmPassword) {
                    jPulse.UI.toast.error(`{{i18n.view.user.settings.passwordsDoNotMatch}}`);
                    return;
                }

                if (newPassword.length < 8) {
                    jPulse.UI.toast.error(`{{i18n.view.user.settings.passwordTooShort}}`);
                    return;
                }

                // Save password
                const passwordData = {
                    currentPassword: currentPassword,
                    newPassword: newPassword
                };

                const passwordResult = await jPulse.api.put('/api/1/user/password', passwordData);

                if (!passwordResult.success) {
                    jPulse.UI.toast.error(passwordResult.error || `{{i18n.view.user.settings.failedToUpdatePassword}}`);
                    return;
                }
            }

            // Success - show appropriate message
            const successMessage = isChangingPassword
                ? `{{i18n.view.user.settings.profileAndPasswordUpdatedSuccess}}`
                : `{{i18n.view.user.settings.profileUpdatedSuccess}}`;

            jPulse.UI.toast.success(successMessage);

            // W-129: Apply updated theme immediately (no page reload needed)
            (function applyThemeIfChanged() {
                const newThemeRaw = profileData?.preferences?.theme || 'light';
                const newTheme = (/^[a-zA-Z0-9_-]+$/.test(newThemeRaw) ? newThemeRaw : 'light');
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';

                if (newTheme !== currentTheme) {
                    // Use the same preview helper (updates theme CSS + Prism CSS)
                    applyThemePreview(newTheme);
                }

                // Ensure the "original" theme for this edit session reflects the saved state
                originalThemePreview = newTheme;
                if (originalValues && typeof originalValues === 'object') {
                    originalValues.theme = newTheme;
                }
            })();

            // Exit edit mode and reload data
            editMode = false;
            // Do not revert theme after save (keep the saved theme active)
            cancelEdit({ revertTheme: false });
            await loadSettingsProfile();

        } catch (error) {
            jPulse.UI.toast.error(`{{i18n.view.user.settings.networkError}}`.replace('%ERROR%', error.message));
        }
    }

    async function loadSettingsProfile() {
        try {
            // W-107: Request user data with schema extensions metadata
            const result = await jPulse.api.get('/api/1/user?includeSchema=1');
            if (result.success && result.data) {
                const user = result.data;
                currentUserData = user;  // W-107: Store for plugin cards

                // W-107: Store schema metadata if provided
                if (result.schema) {
                    schemaMetadata = result.schema;
                }

                // Update form fields
                document.getElementById('firstName').value = user.profile?.firstName || '';
                document.getElementById('lastName').value = user.profile?.lastName || '';
                document.getElementById('nickName').value = user.profile?.nickName || '';
                document.getElementById('email').value = user.email || '';

                // Update preferences
                document.getElementById('language').value = user.preferences?.language || `{{appConfig.utils.i18n.default}}` || 'en';
                document.getElementById('theme').value = user.preferences?.theme || 'light';

                // Update status badge
                const statusBadge = document.querySelector('.jp-status-badge');
                if (statusBadge && user.status) {
                    statusBadge.textContent = user.status;
                    statusBadge.className = `jp-status-badge jp-status-${user.status}`;
                }

                // W-107: Render plugin cards based on schema
                await loadPluginConfig();
                renderPluginCards();
            } else {
                jPulse.UI.toast.error(result.error || `{{i18n.view.user.settings.failedToLoadProfile}}`);
            }
        } catch (error) {
            jPulse.UI.toast.error(`{{i18n.view.user.settings.networkErrorLoadingProfile}}`.replace('%ERROR%', error.message));
        }
    }

    // W-107: Load plugin configuration from database
    // TODO: Implement proper /api/1/plugin/config endpoint in future
    async function loadPluginConfig() {
        // For now, plugin config-based showIf conditions will use empty config
        // This means actions with showIf: { config: '...' } will default to hidden
        pluginConfig = {};
    }

    // W-107: Render plugin cards based on schema extensions
    function renderPluginCards() {
        const container = document.getElementById('pluginCardsContainer');
        container.innerHTML = '';

        if (!schemaMetadata || Object.keys(schemaMetadata).length === 0) {
            return;
        }

        // Sort plugins by order - use userCard for user's own profile
        const sortedBlocks = Object.entries(schemaMetadata)
            .filter(([key, blockDef]) => blockDef._meta?.userCard?.visible)
            .sort((a, b) => (a[1]._meta?.userCard?.order || 999) - (b[1]._meta?.userCard?.order || 999));

        sortedBlocks.forEach(([blockKey, blockDef]) => {
            const cardConfig = blockDef._meta.userCard;
            const cardHtml = renderPluginCard(blockKey, blockDef, cardConfig);
            container.insertAdjacentHTML('beforeend', cardHtml);
        });
    }

    // W-107: Render a single plugin card
    function renderPluginCard(blockKey, blockDef, cardConfig) {
        const userData = currentUserData[blockKey] || {};
        const icon = cardConfig.icon || 'üì¶';
        const label = cardConfig.label || blockKey;
        const description = cardConfig.description || '';

        // Build action buttons
        const actionsHtml = renderCardActions(blockKey, cardConfig.actions || [], userData);

        // Build fields display - use userCard visibility
        const fieldsHtml = renderCardFields(blockKey, blockDef, userData);

        return `
            <div class="jp-card local-plugin-card" id="card-${blockKey}">
                <div class="local-plugin-card-header">
                    <div class="local-plugin-card-title">
                        <span class="local-plugin-icon">${icon}</span>
                        <h3>${label}</h3>
                    </div>
                    <div class="local-plugin-card-actions">
                        ${actionsHtml}
                    </div>
                </div>
                ${description ? `<div class="local-plugin-card-description">${description}</div>` : ''}
                <div class="local-plugin-field-grid">
                    ${fieldsHtml}
                </div>
            </div>
        `;
    }

    // Parse CSS color strings to RGB (supports #RGB, #RRGGBB, rgb(), rgba()).
    function parseCssColor(color) {
        if (!color) return null;
        const c = String(color).trim();

        // #RGB or #RRGGBB
        const hexMatch = c.match(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/);
        if (hexMatch) {
            let hex = hexMatch[1];
            if (hex.length === 3) {
                hex = hex.split('').map(ch => ch + ch).join('');
            }
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return { r, g, b };
        }

        // rgb()/rgba()
        const rgbMatch = c.match(/^rgba?\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})(?:\s*,\s*([0-9.]+))?\s*\)$/);
        if (rgbMatch) {
            const r = Math.min(255, Math.max(0, parseInt(rgbMatch[1], 10)));
            const g = Math.min(255, Math.max(0, parseInt(rgbMatch[2], 10)));
            const b = Math.min(255, Math.max(0, parseInt(rgbMatch[3], 10)));
            return { r, g, b };
        }

        return null;
    }

    // WCAG relative luminance for sRGB.
    function getRelativeLuminance(rgb) {
        const toLinear = (v) => {
            const s = v / 255;
            return s <= 0.04045 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
        };
        const r = toLinear(rgb.r);
        const g = toLinear(rgb.g);
        const b = toLinear(rgb.b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    // W-107: Render card action buttons
    function renderCardActions(blockKey, actions, userData) {
        if (!actions || actions.length === 0) return '';

        return actions
            .filter(action => evaluateShowIf(action.showIf, userData, blockKey))
            .map(action => {
                const style = action.style || 'secondary';
                const icon = action.icon ? `${action.icon} ` : '';
                const btnClass = `jp-btn jp-btn-${style} jp-btn-sm`;
                return `<button class="${btnClass}" onclick="handlePluginAction('${blockKey}', ${JSON.stringify(action).replace(/'/g, "\\'").replace(/"/g, '&quot;')})">${icon}${action.label}</button>`;
            })
            .join('');
    }

    // W-107: Evaluate showIf condition
    function evaluateShowIf(showIf, userData, blockKey) {
        if (!showIf) return true;

        // Simple conditions
        if (showIf === 'always') return true;
        if (showIf === 'hasValue') return false; // For action buttons, default to true if no showIf

        // Field-based condition: { field: 'mfa.enabled', equals: true }
        if (showIf.field) {
            let value = getSettingsNestedValue(currentUserData, showIf.field);

            // Apply default from schema if value is undefined
            if (value === undefined) {
                const parts = showIf.field.split('.');
                if (parts.length >= 2) {
                    const schemaBlock = schemaMetadata[parts[0]];
                    const fieldDef = schemaBlock?.[parts[1]];
                    if (fieldDef?.default !== undefined) {
                        value = fieldDef.default;
                    }
                }
            }

            if (showIf.equals !== undefined) {
                return value === showIf.equals;
            }
            if (showIf.condition === 'exists') {
                return value !== null && value !== undefined;
            }
            if (showIf.condition === 'gt' && showIf.value !== undefined) {
                return value > showIf.value;
            }
            return false;
        }

        // Config-based condition: { config: 'auth-mfa.allowUserDisable', equals: true }
        if (showIf.config) {
            const value = getSettingsNestedValue(pluginConfig, showIf.config);
            return value === showIf.equals;
        }

        // All condition: { all: [...conditions] }
        if (showIf.all && Array.isArray(showIf.all)) {
            return showIf.all.every(cond => evaluateShowIf(cond, userData, blockKey));
        }

        // Any condition: { any: [...conditions] }
        if (showIf.any && Array.isArray(showIf.any)) {
            return showIf.any.some(cond => evaluateShowIf(cond, userData, blockKey));
        }

        return true;
    }

    // W-107: Get nested value from object using dot notation
    function getSettingsNestedValue(obj, path) {
        if (!obj || !path) return undefined;
        return path.split('.').reduce((acc, part) => acc?.[part], obj);
    }

    // W-107: Set nested value in object using dot notation
    function setSettingsNestedValue(obj, path, value) {
        const parts = path.split('.');
        const last = parts.pop();
        const target = parts.reduce((acc, part) => {
            if (acc[part] === undefined) acc[part] = {};
            return acc[part];
        }, obj);
        target[last] = value;
    }

    // W-107: Render card fields (using userCard visibility)
    function renderCardFields(blockKey, blockDef, userData) {
        const fields = [];

        for (const [fieldKey, fieldDef] of Object.entries(blockDef)) {
            if (fieldKey === '_meta') continue;
            if (!fieldDef.userCard?.visible) continue;  // Use userCard for user profile

            // Get value with fallback to default from schema
            let value = userData[fieldKey];
            if (value === undefined && fieldDef.default !== undefined) {
                value = fieldDef.default;
            }

            // Check showIf
            const showIf = fieldDef.showIf;
            if (showIf === 'hasValue' && (value === null || value === undefined)) {
                continue;
            }
            if (typeof showIf === 'object' && !evaluateShowIf(showIf, userData, blockKey)) {
                continue;
            }

            const label = fieldDef.label || fieldKey;
            const displayValue = formatSettingsFieldValue(value, fieldDef);

            fields.push(`
                <div class="local-plugin-field-label">${label}:</div>
                <div class="local-plugin-field-value">${displayValue}</div>
            `);
        }

        return fields.join('');
    }

    // W-107: Format field value based on displayAs
    function formatSettingsFieldValue(value, fieldDef) {
        const displayAs = fieldDef.displayAs;

        if (value === null || value === undefined) {
            return '<span class="jp-text-muted">‚Äî</span>';
        }

        switch (displayAs) {
            case 'badge':
                if (typeof value === 'boolean') {
                    const badgeClass = value ? 'local-plugin-badge-success' : 'local-plugin-badge-danger';
                    const badgeText = value ? '‚úÖ Enabled' : '‚ùå Disabled';
                    return `<span class="local-plugin-badge ${badgeClass}">${badgeText}</span>`;
                }
                return `<span class="local-plugin-badge local-plugin-badge-info">${value}</span>`;

            case 'date':
                if (!value) return '<span class="jp-text-muted">‚Äî</span>';
                return jPulse.date.formatLocalDate(value);

            case 'datetime':
                if (!value) return '<span class="jp-text-muted">‚Äî</span>';
                return jPulse.date.formatLocalDateAndTime(value);

            case 'count':
                if (Array.isArray(value)) {
                    return `${value.length} remaining`;
                }
                return String(value);

            default:
                if (typeof value === 'boolean') {
                    return value ? '{{i18n.view.user.settings.yes}}' : '{{i18n.view.user.settings.no}}';
                }
                if (Array.isArray(value)) {
                    return value.join(', ');
                }
                return String(value);
        }
    }

    // W-107: Handle plugin action button click
    async function handlePluginAction(blockKey, action) {
        // Parse action if it's a string (from HTML attribute)
        if (typeof action === 'string') {
            action = JSON.parse(action.replace(/&quot;/g, '"'));
        }

        // Show confirmation dialog if required
        if (action.confirm) {
            const result = await jPulse.UI.confirmDialog({
                title: action.label,
                message: action.confirm,
                buttons: ['{{i18n.view.user.settings.cancel}}', '{{i18n.view.user.settings.continue}}']
            });
            if (result.button !== '{{i18n.view.user.settings.continue}}') return;
        }

        // Handle different action types
        if (action.setFields) {
            // Enter edit mode FIRST to capture original values before modification
            if (!editMode) {
                toggleEditMode();
            }

            // Apply setFields to currentUserData (local modification)
            for (const [path, value] of Object.entries(action.setFields)) {
                setSettingsNestedValue(currentUserData, path, value);
            }

            // Re-render the card
            renderPluginCards();

            // Show toast
            if (action.toast) {
                jPulse.UI.toast.info(action.toast);
            }
        } else if (action.navigate) {
            // Check for unsaved changes
            if (editMode) {
                const result = await jPulse.UI.confirmDialog({
                    title: `{{i18n.view.user.settings.unsavedChangesTitle}}`,
                    message: `{{i18n.view.user.settings.unsavedChangesMessage}}`,
                    buttons: [`{{i18n.view.user.settings.cancel}}`, `{{i18n.view.user.settings.saveAndContinue}}`]
                });
                if (result.button === `{{i18n.view.user.settings.cancel}}`) return;
                await saveProfile();
            }
            window.location.href = action.navigate;
        } else if (action.handler) {
            // Call registered handler
            const handler = window.jPulse?.schemaHandlers?.[action.handler];
            if (handler) {
                const result = await handler(currentUserData, action);
                if (result?.refresh) {
                    await loadSettingsProfile();
                }
            } else {
                console.error(`- jPulse: Handler not found: ${action.handler}`);
                jPulse.UI.toast.error('{{i18n.view.user.settings.handlerNotAvailable}}'.replace('%HANDLER%', action.handler));
            }
        }
    }

    async function loadSettingsLanguages() {
        try {
            const response = await jPulse.api.get('/api/1/auth/languages');

            if (response.success) {
                const languageSelect = document.getElementById('language');
                const currentValue = languageSelect.value;

                languageSelect.innerHTML = '';

                const languages = response.data;
                if (Array.isArray(languages)) {
                    languages.forEach(([code, name]) => {
                        const option = document.createElement('option');
                        option.value = code;
                        option.textContent = name;
                        languageSelect.appendChild(option);
                    });
                } else {
                    console.error('- jPulse: Languages data is not an array:', languages);
                    jPulse.UI.toast.error('{{i18n.view.user.settings.invalidLanguageDataFormat}}');
                }

                languageSelect.value = currentValue;
            } else {
                const errorMsg = response.error || '{{i18n.view.user.settings.unknownError}}';
                jPulse.UI.toast.error('{{i18n.view.user.settings.failedToLoadLanguageOptions}}'.replace('%ERROR%', errorMsg));
            }
        } catch (error) {
            console.error('- jPulse: Failed to load languages:', error);
            jPulse.UI.toast.error('{{i18n.view.user.settings.failedToLoadLanguageOptionsRefresh}}');
        }
    }

    async function loadSettingsThemes() {
        try {
            const response = await jPulse.api.get('/api/1/user/enums?fields=preferences.theme');

            if (response.success && response.data && response.data['preferences.theme']) {
                const themeSelect = document.getElementById('theme');
                const currentValueRaw = themeSelect.value;
                const currentValue = currentValueRaw || 'light';

                themeSelect.innerHTML = '';

                const themes = response.data['preferences.theme'];
                if (Array.isArray(themes)) {
                    themes.forEach(theme => {
                        const option = document.createElement('option');
                        option.value = theme;
                        option.textContent = theme;
                        themeSelect.appendChild(option);
                    });
                } else {
                    console.error('- jPulse: Themes data is not an array:', themes);
                    jPulse.UI.toast.error('{{i18n.view.user.settings.invalidThemeDataFormat}}');
                }

                themeSelect.value = currentValue;
                if (themeSelect.value !== currentValue && themeSelect.options.length > 0) {
                    // If currentValue is not part of the enum list, fall back to first option.
                    themeSelect.selectedIndex = 0;
                }
            } else {
                const errorMsg = response.error || '{{i18n.view.user.settings.unknownError}}';
                jPulse.UI.toast.error('{{i18n.view.user.settings.failedToLoadThemeOptions}}'.replace('%ERROR%', errorMsg));
            }
        } catch (error) {
            console.error('- jPulse: Failed to load themes:', error);
            jPulse.UI.toast.error('{{i18n.view.user.settings.failedToLoadThemeOptionsRefresh}}');
        }
    }
{{/if}}
{{/component}}

<!-- EOF webapp/view/user/settings.tmpl -->
